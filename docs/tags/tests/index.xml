<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tests on rapatao.com</title><link>https://www.rapatao.com/tags/tests/</link><description>Recent content in Tests on rapatao.com</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sat, 05 Oct 2024 20:00:00 +0000</lastBuildDate><atom:link href="https://www.rapatao.com/tags/tests/index.xml" rel="self" type="application/rss+xml"/><item><title>Fixing memory issues while running tests on Spring Boot using Kafka</title><link>https://www.rapatao.com/posts/2024-10/fixing-memory-issues-while-running-tests-on-spring-boot-using-kafka/</link><pubDate>Sat, 05 Oct 2024 20:00:00 +0000</pubDate><guid>https://www.rapatao.com/posts/2024-10/fixing-memory-issues-while-running-tests-on-spring-boot-using-kafka/</guid><description>&lt;p>Recently, I faced a problem in an application where it was taking too long to run its tests. After checking the reasons,
I found out that the embedded Kafka provided by Spring was consuming too much memory, making it hard for the GC to free
up space to allow all the remaining tests to execute.&lt;/p>
&lt;p>That embedded solution worked fine at the beginning of the project, where a few test cases really needed to use that
resource to validate its use cases. As soon as the project gets bigger and more test cases are required to use that
resource, an issue with the testing execution starts to show up, and the test execution time is drastically starting to
increase.&lt;/p></description></item><item><title>What are Flaky Tests and why fix them!</title><link>https://www.rapatao.com/posts/2022-08/what-are-flaky-tests-and-why-fix-them/</link><pubDate>Sun, 28 Aug 2022 12:00:00 -0300</pubDate><guid>https://www.rapatao.com/posts/2022-08/what-are-flaky-tests-and-why-fix-them/</guid><description>&lt;p>Building tests is surely one of the most difficult and time-consuming tasks for a developer, in addition to usually generating more lines of code than the added functionality. This is due to the various scenarios that need, or should, be verified.&lt;/p>
&lt;p>&lt;em>Flaky Tests&lt;/em>, are basically test cases created to verify a scenario, however, they can randomly present success and failure results, without having undergone any change, neither in the test case nor in the tested code.&lt;/p></description></item><item><title>Build tests using Kotlin, JUnit and MockK</title><link>https://www.rapatao.com/posts/2022-01/build-tests-using-kotlin-junit-mockk/</link><pubDate>Wed, 19 Jan 2022 22:00:00 -0300</pubDate><guid>https://www.rapatao.com/posts/2022-01/build-tests-using-kotlin-junit-mockk/</guid><description>&lt;p>The main objective of building code tests in an application is to certify what was coded, that is, to guarantee that a
given piece of code does what it should do.&lt;/p>
&lt;p>&lt;a href="https://junit.org/junit5/">JUnit&lt;/a> is one of the most used frameworks for building tests
in &lt;a href="https://kotlinlang.org/">Kotlin&lt;/a> and &lt;a href="https://mockk.io/">MockK&lt;/a> to build &lt;em>mocks&lt;/em>, which would be like doubles of an
object and have the function of simulating the behavior of a component.&lt;/p>
&lt;aside>
ðŸ’¡ The codes used in this text are available on GitHub: https://github.com/rapatao/blog-koltin-junit-mockk
&lt;/aside>
&lt;h2 id="dependÃªncias-utilizadas">DependÃªncias utilizadas&lt;/h2>
&lt;p>It is important to say that there are several ways to add support to the language and frameworks that we will use in
this text. In the example below, only one of them will be presented, being basically how
&lt;em>&lt;a href="https://www.jetbrains.com/idea/">IntelliJ IDEA&lt;/a>&lt;/em> initializes projects in &lt;em>Kotlin&lt;/em> + &lt;em>&lt;a href="https://gradle.org/">Gradle&lt;/a>&lt;/em>.&lt;/p></description></item><item><title>Optimizing tests in Spring Boot applications</title><link>https://www.rapatao.com/posts/2021-06/optimizing-tests-in-spring-boot-applications/</link><pubDate>Thu, 24 Jun 2021 22:00:00 -0300</pubDate><guid>https://www.rapatao.com/posts/2021-06/optimizing-tests-in-spring-boot-applications/</guid><description>&lt;p>It is extremely common for applications built with Spring Boot to have all their tests annotated with &lt;code>@SpringBootTest&lt;/code>, but it is rare to find people who know the functionality of this annotation, when it is necessary to use it and its impact on the execution of an application&amp;rsquo;s tests.&lt;/p>
&lt;p>You probably thought that this annotation is for building tests, but do you know what it represents, what happens when it is used?&lt;/p></description></item><item><title>Verify vararg methods using Mockito</title><link>https://www.rapatao.com/posts/2020-05/verify-varargs-using-mockito/</link><pubDate>Thu, 14 May 2020 00:00:00 -0300</pubDate><guid>https://www.rapatao.com/posts/2020-05/verify-varargs-using-mockito/</guid><description>&lt;p>Building tests is one of the most routine tasks for a developer and normally, with frameworks like jUnit and Mockito, this task tends to be carried out without great difficulties. Despite this, there are certain validations, which tend to be more complex, such as checking calls to methods with parameters of type &lt;em>varargs&lt;/em>.&lt;/p>
&lt;p>If you don&amp;rsquo;t know what &lt;em>varargs&lt;/em> is, you can roughly say that it is, the &amp;ldquo;&amp;hellip;&amp;rdquo; used in parameter declarations in methods, however, I recommend reading &lt;a href="https://www.geeksforgeeks.org/variable-arguments-varargs-in-java/">this article&lt;/a> for better understanding and viewing examples.&lt;/p></description></item></channel></rss>
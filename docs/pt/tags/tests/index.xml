<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tests on rapatao.com</title><link>https://www.rapatao.com/pt/tags/tests/</link><description>Recent content in Tests on rapatao.com</description><generator>Hugo</generator><language>pt</language><lastBuildDate>Sun, 28 Aug 2022 12:00:00 -0300</lastBuildDate><atom:link href="https://www.rapatao.com/pt/tags/tests/index.xml" rel="self" type="application/rss+xml"/><item><title>O que s√£o Flaky Tests e, porque corrigi-los!</title><link>https://www.rapatao.com/pt/posts/2022-08/o-que-sao-flaky-tests-e-porque-corrigi-los/</link><pubDate>Sun, 28 Aug 2022 12:00:00 -0300</pubDate><guid>https://www.rapatao.com/pt/posts/2022-08/o-que-sao-flaky-tests-e-porque-corrigi-los/</guid><description>&lt;p>Construir testes √©, seguramente, uma das tarefas mais dif√≠ceis e que mais consomem o tempo de um desenvolvedor, al√©m de normalmente gerarem mais linhas de c√≥digo que a funcionalidade adicionada. Isso ocorre devido aos diversos cen√°rios que precisam, ou deveriam, ser verificados.&lt;/p>
&lt;p>&lt;em>Flaky Tests&lt;/em>, s√£o basicamente casos de testes criados para verifica√ß√£o de um cen√°rio, por√©m, podem apresentar aleatoriamente resultados de sucesso e falha, sem ter sofrido qualquer altera√ß√£o, nem no caso de teste, nem no c√≥digo testado.&lt;/p></description></item><item><title>Construindo testes com Kotlin, JUnit e MockK</title><link>https://www.rapatao.com/pt/posts/2022-01/construindo-testes-com-kotlin-junit-mockk/</link><pubDate>Wed, 19 Jan 2022 22:00:00 -0300</pubDate><guid>https://www.rapatao.com/pt/posts/2022-01/construindo-testes-com-kotlin-junit-mockk/</guid><description>&lt;p>A constru√ß√£o de testes de c√≥digo em uma aplica√ß√£o tem como principal objetivo certificar o que foi codificado, ou seja,
garantir que um determinado trecho de c√≥digo faz o que deveria fazer.&lt;/p>
&lt;p>&lt;a href="https://junit.org/junit5/">JUnit&lt;/a> √© um dos frameworks mais utilizados na constru√ß√£o de testes
em &lt;a href="https://kotlinlang.org/">Kotlin&lt;/a> e &lt;a href="https://mockk.io/">MockK&lt;/a> para constru√ß√£o de &lt;em>mocks&lt;/em>, que seriam como dubl√™s de
um objeto e tem como fun√ß√£o simular o comportamento de um componente.&lt;/p>
&lt;aside>
üí° Os c√≥digo utilizados nesse texto est√£o dispon√≠veis no GitHub: https://github.com/rapatao/blog-koltin-junit-mockk
&lt;/aside>
&lt;h2 id="depend√™ncias-utilizadas">Depend√™ncias utilizadas&lt;/h2>
&lt;p>√â importante dizer que, existem diversas formas de adicionar suporte a linguagem e frameworks que iremos utilizar neste
texto. No exemplo abaixo, ser√° apresentado apenas uma delas, sendo basicamente como o
&lt;em>&lt;a href="https://www.jetbrains.com/idea/">IntelliJ IDEA&lt;/a>&lt;/em> inicializa projetos em &lt;em>Kotlin&lt;/em> + &lt;em>&lt;a href="https://gradle.org/">Gradle&lt;/a>&lt;/em>.&lt;/p></description></item><item><title>Otimizando testes em aplica√ß√µes com Spring Boot</title><link>https://www.rapatao.com/pt/posts/2021-06/otimizando-testes-em-aplicacoes-com-spring-boot/</link><pubDate>Thu, 24 Jun 2021 22:00:00 -0300</pubDate><guid>https://www.rapatao.com/pt/posts/2021-06/otimizando-testes-em-aplicacoes-com-spring-boot/</guid><description>&lt;p>√â extremamente comum aplica√ß√µes constru√≠das com Spring Boot possuir todos seus testes anotados com &lt;code>@SpringBootTest&lt;/code>, por√©m √© raro encontrar pessoas que sabem a funcionalidade dessa anota√ß√£o, quando √© necess√°ria sua utiliza√ß√£o e seu impacto na execu√ß√£o dos testes de uma aplica√ß√£o.&lt;/p>
&lt;p>Voc√™ provavelmente deve ter pensado que essa anota√ß√£o serve para a constru√ß√£o de testes, mas voc√™ sabe o que isso representa, o que acontece quando ela √© utilizada?&lt;/p>
&lt;p>Simploriamente, essa anota√ß√£o √© uma forma simplificada de adicionar uma extens√£o ao &lt;a href="https://junit.org/junit5/docs/current/user-guide/#extensions">JUnit&lt;/a> que visa inicializar o contexto do Spring antes da execu√ß√£o dos cen√°rios de testes declarados. Com sua utiliza√ß√£o, antes de uma classe de teste ser executada, √© realizado uma busca na aplica√ß√£o pela classe anotada com &lt;code>@SpringBootApplication&lt;/code> para identificar poss√≠veis customiza√ß√µes, carregado as configura√ß√µes para o perfil de teste (quando n√£o sobrescrito) e somente ap√≥s o contexto ser inicializado, temos o m√©todo com o cen√°rio executado.&lt;/p></description></item><item><title>Verifica√ß√£o de varargs utilizando Mockito</title><link>https://www.rapatao.com/pt/posts/2020-05/verify-varargs-using-mockito/</link><pubDate>Thu, 14 May 2020 00:00:00 -0300</pubDate><guid>https://www.rapatao.com/pt/posts/2020-05/verify-varargs-using-mockito/</guid><description>&lt;p>Construir testes √© uma das tarefas mais rotineiras de um desenvolvedor e normalmente, com frameworks como jUnit e Mockito, esta tarefa tende a ser realizada sem grandes dificuldades. Apesar disso, existem certas valida√ß√µes, que costumam ter maior complexidade, como exemplo, verifica√ß√£o de chamadas a m√©todos com par√¢metros to tipo &lt;em>varargs&lt;/em>.&lt;/p>
&lt;p>Caso n√£o saiba o que √© &lt;em>varargs&lt;/em>, pode-se dizer grosseiramente que √©, o &amp;ldquo;&amp;hellip;&amp;rdquo; utilizado nas declara√ß√µes de par√¢metros em m√©todos, por√©m, recomendo ler &lt;a href="https://www.geeksforgeeks.org/variable-arguments-varargs-in-java/">este artigo&lt;/a> para melhor entendimento e visualiza√ß√£o de exemplos.&lt;/p></description></item></channel></rss>